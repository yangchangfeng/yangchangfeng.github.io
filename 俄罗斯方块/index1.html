<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>俄罗斯方块</title>
    <style>
    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }

    .matrix {
        position: relative;
        left: 120px;
        top: 80px;
        background: #9ead86;
        width: 350px;
    }

    .matrix p {
        width: 220px;
        height: 22px;
    }

    b,
    b:after {
        display: block;
    }

    b.c {
        border-color: #000;
    }

    b.c:after {
        background: #000;
    }

    b.d {
        border-color: #560000;
    }

    b.d:after {
        background: #560000;
    }

    b {
        width: 20px;
        height: 20px;
        padding: 2px;
        border: 2px solid rgba(0, 0, 0, .15);
        margin: 0 2px 2px 0;
        float: left;
    }

    b:after {
        content: "";
        width: 12px;
        height: 12px;
        background: #879372;
        overflow: hidden;
    }

    button {}
    </style>
</head>

<body>
    <div class="matrix">
        <p>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
        </p>
        <p>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
        </p>
        <p>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
        </p>
        <p>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
        </p>
        <p>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
        </p>
        <p>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
        </p>
        <p>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
        </p>
        <p>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
        </p>
        <p>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
        </p>
        <p>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
        </p>
        <p>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
        </p>
        <p>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
        </p>
        <p>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
        </p>
        <p>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
        </p>
        <p>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
        </p>
        <p>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
        </p>
        <p>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
        </p>
        <p>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
        </p>
        <p>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
        </p>
        <p>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
            <b></b>
        </p>
        <button id='parking' style='width:50px;height:50px;'>暂停</button>
    </div>
    <!-- <button style='width:50px;height:50px;'>暂停</button> -->
</body>
<script>
var bgc = new Array(20).fill(0).map(it => new Array(10).fill(0))
//stick是用来判断 那些部分可以move和rotate的
var stick = new Array(20).fill(0).map(it => new Array(10).fill(0))
//记录活动积木的型号，这样方便movie里的旋转操作
var typeNumber

function draw(bgc) {
    // console.log('paint')
    let painter = document.querySelectorAll('b')
    for (let i = 0; i < bgc.length; i++) {
        for (let j = 0; j < bgc[i].length; j++) {
            if (bgc[i][j] == 1) {
                painter[i * 10 + j].classList.add('c')
            } else {
                painter[i * 10 + j].classList.remove('c')
            }
        }
    }
}
draw(bgc)

function dropAndParking() {
    let flag = true
    let dropId = 0

    function drop(ary, dropbrick) {
        if (dropbrick) {
            brickBuilder()
        }
        var lineary = []
        dropId = setInterval(function() {
            for (let i = ary.length - 1; i >= 0; i--) {
                for (let j = 0; j < ary[i].length; j++) {
                    if (ary[i][j] === 1 && stick[i][j] === 0) {
                        if (i === ary.length - 1 || stick[i + 1][j] == 1) {
                        	clearFilled()
                            stick = JSON.parse(JSON.stringify(bgc))
                            //插入清除满行函数直接操作stick
                            // clearFilled()
                            clearInterval(dropId);
                            // console.log('下一轮')
                            return drop(bgc,true)
                        } else {
                            lineary.push([i, j])
                        }
                    }
                }
            }
            lineary.forEach(item => {
                bgc[item[0] + 1][item[1]] = 1;
                bgc[item[0]][item[1]] = 0;
            })
            lineary = []
            draw(ary)
        }, 600)
    }

    function parkingg() {
        parking.addEventListener('click', function(event) {
            console.log(666)
            if (flag) {
                console.log('paring', dropId)
                clearInterval(dropId);
                flag = false
            } else {
                drop(bgc,false);
                flag = true
            }
        })
    }
    drop(bgc,true)
    parkingg()
}
dropAndParking()

function brickBuilder() {
    //砖块一共有7种
    var mark = Math.floor(Math.random() * 7)
    typeNumber = mark
    var storage = [
        [
            [0, 4],
            [0, 5],
            [1, 4],
            [1, 5]
        ],
        [
            [0, 3],
            [0, 4],
            [0, 5],
            [0, 6]
        ],
        [
            [1, 4],
            [1, 5],
            [1, 6],
            [0, 5]
        ],
        [
            [0, 4],
            [0, 5],
            [1, 5],
            [1, 6]
        ],
        [
            [1, 4],
            [1, 5],
            [0, 5],
            [0, 6]
        ],
        [
            [1, 4],
            [1, 5],
            [1, 6],
            [0, 6]
        ],
        [
            [0, 4],
            [1, 4],
            [1, 5],
            [1, 6]
        ]
    ]
    storage[mark].forEach(item => {
        bgc[item[0]][item[1]] = 1
    })
    draw(bgc)
}

function moveBottom() {
    console.log('向下向下')
    let ary = []
    let point = 0
    for (let i = bgc.length - 1; i >= 0; i--) {
        for (let j = 0; j < bgc[i].length; j++) {
            if (bgc[i][j] == 1 && stick[i][j] != 1) {
                ary.push([i, j])
            }
        }
    }
    // console.log(JSON.stringify(ary))
    let minrange = minRange(ary)
    // console.log('最小值', minrange, JSON.stringify(stick))
    if (minrange > 2) point = 3;
    else point = minrange;
    if (point !== 1) flag = false;
    for (let i = 0; i < point - 1; i++) {
        setTimeout(() => {
            ary.forEach(item => {
                bgc[item[0] + 1 + i][item[1]] = 1;
                bgc[item[0] + i][item[1]] = 0;
                if (i == point - 2) flag = true;
                draw(bgc)
            })
        }, i * 40)
    }
}

function minRange(ary) {
    var storage = []
    ary.forEach(item => {
        let flag = true
        for (let i = item[0]; i <= bgc.length - 1; i++) {
            if (stick[i][item[1]] === 1) {
                storage.push(i - item[0])
                flag = false
                break;
            }
        }
        if (flag) {
            storage.push(bgc.length - item[0])
        }
    })
    return Math.min(...storage)
}
//向下加速时有若干setTimeout异步事件，这时候按左右键会穿插进异步里造成积木分裂，设置flag来判断异步是否完成
var flag = true

function movie() {
    addEventListener('keydown', function(event) {
        // console.log(event.keyCode)
        event.preventDefault();
        //从上到下，从左到右的顺序将活动积木的四个坐标记录下来
        function photo() {
            let ary = []
            for (let i = 0; i < bgc.length; i++) {
                for (let j = 0; j < bgc[i].length; j++) {
                    if (bgc[i][j] == 1 && stick[i][j] != 1) {
                        ary.push([i, j])
                    }
                }
            }
            return ary
        }
        //向左移动
        if (event.keyCode === 37 && flag) {
            let ary = photo()
            if (ary.every(item =>
                    item[1] !== 0
                ) && ary.every(item => stick[item[0]][item[1] - 1] !== 1)) {
                //当没碰到墙壁时and左边没有积木时
                ary.forEach(item => {
                    bgc[item[0]][item[1]] = 0;
                    bgc[item[0]][item[1] - 1] = 1;
                })
            }
            draw(bgc)
        }
        //向右移动
        else if (event.keyCode === 39 && flag) {
            //这个不能用photo 因为这里的j的顺序和下面的逻辑有关联
            let ary = []
            for (let i = 0; i < bgc.length; i++) {
                for (let j = bgc[i].length - 1; j >= 0; j--) {
                    if (bgc[i][j] == 1 && stick[i][j] != 1) {
                        ary.push([i, j])
                    }
                }
            }
            if (ary.every(item => item[1] !== bgc[0].length - 1) && ary.every(item => stick[item[0]][item[1] + 1] !== 1)) {
                ary.forEach(item => {
                    bgc[item[0]][item[1]] = 0;
                    bgc[item[0]][item[1] + 1] = 1
                })
            }
            draw(bgc)
        }
        //向下加速
        else if (event.keyCode === 40 && flag) {
            moveBottom()
        }
        //空格键瞬间补位完成
        else if (event.keyCode === 32) {
            let ary = photo()
            var l = minRange(ary) - 1
            ary.forEach(item => {
                bgc[item[0]][item[1]] = 0;
                bgc[item[0] + l][item[1]] = 1;
            })
            draw(bgc)
        }
        //旋转
        else if (event.keyCode === 38) {
            let ary = photo()
            if (typeNumber == 1) {
                if (ary[1][1] > 0 && ary[1][1] < 8) {
                    //由—— 变 |
                    //限制条件分别是左墙限制，右墙限制，下边限制123
                    if (ary[0][0] == ary[1][0] && ary[1][0] < 18 && stick[ary[1][0] + 1][ary[1][1]] !== 1 && stick[ary[1][0] + 2][ary[1][1]] !== 1) {
                        bgc[ary[0][0]][ary[0][1]] = 0;
                        bgc[ary[2][0]][ary[2][1]] = 0;
                        bgc[ary[3][0]][ary[3][1]] = 0;
                        bgc[ary[1][0] - 1][ary[1][1]] = 1;
                        bgc[ary[1][0] + 1][ary[1][1]] = 1;
                        bgc[ary[1][0] + 2][ary[1][1]] = 1;
                        draw(bgc)
                    }
                    // 由 | 变 —— 
                    if (ary[0][0] !== ary[1][0] && stick[ary[1][0]][ary[1][1] - 1] !== 1 && stick[ary[1][0]][ary[1][1] + 1] !== 1 && stick[ary[1][0]][ary[1][1] + 2] !== 1) {
                        bgc[ary[0][0]][ary[0][1]] = 0;
                        bgc[ary[2][0]][ary[2][1]] = 0;
                        bgc[ary[3][0]][ary[3][1]] = 0;
                        bgc[ary[1][0]][ary[1][1] - 1] = 1;
                        bgc[ary[1][0]][ary[1][1] + 1] = 1;
                        bgc[ary[1][0]][ary[1][1] + 2] = 1;
                        draw(bgc)
                    }
                }
            } else if (typeNumber == 2) {
                //山丘头朝上 （由上到左）
                if (ary[2][0] == ary[0][0] + 1 && ary[2][1] == ary[0][1] && ary[0][0] + 1 == ary[3][0]) {
                    if (stick[ary[2][0] + 1][ary[2][1]] == 0) {
                        bgc[ary[3][0]][ary[3][1]] = 0;
                        bgc[ary[2][0] + 1][ary[2][1]] = 1;
                        draw(bgc)
                    }
                } else if (ary[2][0] == ary[0][0] + 1 && ary[2][1] == ary[0][1]) {
                    //山丘头朝左（由左到下）
                    if (stick[ary[2][0]][ary[2][1] + 1] == 0) {
                        bgc[ary[0][0]][ary[0][1]] = 0;
                        bgc[ary[2][0]][ary[2][1] + 1] = 1;
                        draw(bgc)
                    }

                } else if (ary[1][0] == ary[0][0] && ary[1][1] == ary[0][1] + 1 && ary[0][1] + 2 == ary[2][1]) {
                    //山丘头朝下 （由下到右）因为变化的部分朝上 不用考虑是否会碰撞到已经固定的积木
                    bgc[ary[0][0]][ary[0][1]] = 0;
                    bgc[ary[1][0] - 1][ary[1][1]] = 1;
                    draw(bgc)
                } else {
                    //山丘头朝右 （由右到上）
                    if (stick[ary[1][0]][ary[1][1] - 1] == 0) {
                        bgc[ary[3][0]][ary[3][1]] = 0;
                        bgc[ary[1][0]][ary[1][1] - 1] = 1;
                        draw(bgc)
                    }
                }
            } else if (typeNumber == 3) {
                //z型积木 从横着到竖着
                if (ary[0][0] == ary[1][0]) {
                    if (stick[ary[0][0] + 1][ary[0][1]] == 0 && stick[ary[0][0] + 2][ary[0][1]] == 0) {
                        bgc[ary[0][0]][ary[0][1]] = 0;
                        bgc[ary[3][0]][ary[3][1]] = 0;
                        bgc[ary[0][0] + 1][ary[0][1]] = 1;
                        bgc[ary[0][0] + 2][ary[0][1]] = 1;
                        draw(bgc)
                    }
                } //从竖着到横着
                else {
                    if (stick[ary[2][0]][ary[2][1] + 1] == 0) {
                        bgc[ary[1][0]][ary[1][1]] = 0;
                        bgc[ary[3][0]][ary[3][1]] = 0;
                        bgc[ary[0][0]][ary[0][1] - 1] = 1;
                        bgc[ary[2][0]][ary[2][1] + 1] = 1;
                        draw(bgc)
                    }
                }
            } else if (typeNumber == 4) {
                //反z型积木 从横着到竖着
                if (ary[0][0] == ary[1][0]) {
                    bgc[ary[1][0]][ary[1][1]] = 0;
                    bgc[ary[2][0]][ary[2][1]] = 0;
                    bgc[ary[2][0] - 1][ary[2][1]] = 1;
                    bgc[ary[2][0] - 2][ary[2][1]] = 1;
                    draw(bgc)
                } //从竖着到横着
                else {
                    if (stick[ary[1][0] + 1][ary[1][1]] == 0 && stick[ary[2][0]][ary[2][1] + 1] == 0) {
                        bgc[ary[0][0]][ary[0][1]] = 0;
                        bgc[ary[1][0]][ary[1][1]] = 0;
                        bgc[ary[1][0] + 1][ary[1][1]] = 1;
                        bgc[ary[2][0]][ary[2][1] + 1] = 1;
                        draw(bgc)
                    }
                }
            } else if (typeNumber == 5) {
                //正7头朝上，头朝上 到 头朝左（到正常书写的7）
                if (ary[1][0] == ary[2][0] && ary[1][0] == ary[3][0]) {
                    if (stick[ary[2][0] + 1][ary[2][1]] == 0) {
                        bgc[ary[0][0]][ary[0][1]] = 0;
                        bgc[ary[1][0]][ary[1][1]] = 0;
                        bgc[ary[3][0]][ary[3][1]] = 0;
                        bgc[ary[0][0]][ary[0][1] - 1] = 1;
                        bgc[ary[0][0]][ary[0][1] - 2] = 1;
                        bgc[ary[2][0] + 1][ary[2][1]] = 1;
                        draw(bgc)
                    }
                } else if (ary[1][1] == ary[2][1] && ary[1][1] == ary[3][1]) {
                    //正常7 到 头朝下7
                    if (stick[ary[0][0] + 1][ary[0][1]] == 0 && stick[ary[1][0]][ary[1][1] + 1] == 0) {
                        bgc[ary[2][0]][ary[2][1]] = 0;
                        bgc[ary[3][0]][ary[3][1]] = 0;
                        bgc[ary[0][0] + 1][ary[0][1]] = 1
                        bgc[ary[1][0]][ary[1][1] + 1] = 1
                        draw(bgc)
                    }
                } else if (ary[0][0] == ary[1][0] && ary[0][0] == ary[2][0]) {
                    //头朝下7 到 头朝右
                    if (stick[ary[3][0] + 1][ary[3][1]] == 0 && stick[ary[3][0] + 1][ary[3][1] + 1] == 0) {
                        bgc[ary[1][0]][ary[1][1]] = 0;
                        bgc[ary[2][0]][ary[2][1]] = 0;
                        bgc[ary[3][0] + 1][ary[3][1]] = 1
                        bgc[ary[3][0] + 1][ary[3][1] + 1] = 1
                        draw(bgc)
                    }
                } else {
                    //头朝右 到头朝上 一个循环结束
                    if (stick[ary[0][0]][ary[0][1] + 2] == 0 && stick[ary[1][0]][ary[1][1] + 2] == 0) {
                        bgc[ary[0][0]][ary[0][1]] = 0;
                        bgc[ary[2][0]][ary[2][1]] = 0;
                        bgc[ary[3][0]][ary[3][1]] = 0;
                        bgc[ary[0][0]][ary[0][1] + 2] = 1;
                        bgc[ary[1][0]][ary[1][1] + 2] = 1;
                        bgc[ary[1][0]][ary[1][1] + 1] = 1;
                        draw(bgc)
                    }
                }
            } else if (typeNumber === 6) {
                //反7头朝上，头朝上 到 头朝左
                if (ary[1][0] == ary[2][0] && ary[1][0] == ary[3][0]) {
                    if (stick[ary[1][0] + 1][ary[1][1]] == 0 && stick[ary[2][0] + 1][ary[2][1]] == 0) {
                        bgc[ary[0][0]][ary[0][1]] = 0;
                        bgc[ary[1][0]][ary[1][1]] = 0;
                        bgc[ary[3][0]][ary[3][1]] = 0;
                        bgc[ary[1][0] + 1][ary[1][1]] = 1;
                        bgc[ary[2][0] + 1][ary[2][1]] = 1;
                        bgc[ary[2][0] - 1][ary[2][1]] = 1;
                        draw(bgc)
                    }
                } else if (ary[1][1] == ary[3][1] && ary[1][1] == ary[0][1]) {
                    //头朝左 到 头朝下
                    if (stick[ary[0][0]][ary[0][1] + 1] == 0 && stick[ary[1][0]][ary[1][1] + 1] == 0) {
                        bgc[ary[1][0]][ary[1][1]] = 0;
                        bgc[ary[2][0]][ary[2][1]] = 0;
                        bgc[ary[3][0]][ary[3][1]] = 0;
                        bgc[ary[0][0]][ary[0][1] + 1] = 1
                        bgc[ary[0][0]][ary[0][1] - 1] = 1
                        bgc[ary[1][0]][ary[1][1] + 1] = 1
                        draw(bgc)
                    }
                } else if (ary[0][0] == ary[1][0] && ary[0][0] == ary[2][0]) {
                    //头朝下 到 头朝右
                    if (stick[ary[0][0] + 1][ary[0][1]] == 0 && stick[ary[0][0] + 2][ary[0][1]] == 0) {
                        bgc[ary[2][0]][ary[2][1]] = 0;
                        bgc[ary[3][0]][ary[3][1]] = 0;
                        bgc[ary[0][0] + 1][ary[0][1]] = 1
                        bgc[ary[0][0] + 2][ary[0][1]] = 1
                        draw(bgc)
                    }
                } else {
                    //头朝右 到头朝上 一个循环结束
                    if (stick[ary[2][0]][ary[2][1] + 1] == 0 && stick[ary[2][0]][ary[2][1] + 2] == 0) {
                        bgc[ary[1][0]][ary[1][1]] = 0;
                        bgc[ary[3][0]][ary[3][1]] = 0;
                        bgc[ary[2][0]][ary[2][1] + 1] = 1;
                        bgc[ary[2][0]][ary[2][1] + 2] = 1;
                        draw(bgc)
                    }
                }
            }
        }
    })
}
movie()

function clearFilled() {
    var noteFilled = []
    var noteLittle = []
    bgc.forEach((item, index) => {
        let sum = item.reduce((a, b) => a + b)
        if (sum == 10) {
            noteFilled.push(index)
        }
        if (sum > 0 && sum < 10) {
            noteLittle.push(index)
        }
    })
    if(noteFilled.length==0) return null
    noteFilled.forEach(item => {
        bgc[item].fill(0)
    })
    var i=19
    while (noteLittle.length) {
        var j = noteLittle.pop()
        var temp=JSON.stringify(bgc[j])
        bgc[j].fill(0)
        bgc[i] = JSON.parse(temp)
        i--;
    }
    draw(bgc)
}
</script>

</html>